[
	{
		"id": 1,
		"ques": "What is an access token and refresh token? How do they work and where should we store them on the client-side?",
		"ans": "An access token and a refresh token are both integral components of authentication and authorization systems. An access token serves as a credential used to verify and authorize access to protected resources. It is typically short-lived and grants access to specific services or resources on behalf of the user or client. When a user logs in or authenticates, the server issues an access token to validate subsequent requests for protected resources.On the other hand, a refresh token is a long-lived credential that comes into play when an access token expires or becomes invalid. It is used to obtain a new access token without requiring the user to reauthenticate. The refresh token provides a means to maintain the user's session and reduces the frequency of authentication requests.When it comes to storing these tokens on the client-side, it is crucial to prioritize security. Access tokens are usually stored in memory or a short-lived storage mechanism such as a browser's session storage or an app's memory. This ensures the token is cleared when the session ends. In contrast, refresh tokens need to be stored securely for an extended period. They are commonly stored in secure HTTP-only cookies or secure storage mechanisms like local storage in browsers. For mobile apps, secure storage options such as the Keychain (iOS) or KeyStore (Android) are utilized.It is essential to implement robust security measures to protect these tokens from unauthorized access or exposure. Adhering to best practices and security guidelines specific to your chosen framework or library is strongly recommended. By doing so, you can ensure the integrity of token-based authentication systems and safeguard user data and resources."
	},
	{
		"id": 2,
		"ques": "Compare SQL and NoSQL databases?",
		"ans": "SQL (Structured Query Language) and NoSQL (Not Only SQL) databases are two distinct types of database management systems with differing approaches to storing and retrieving data. SQL databases follow a structured data model with predefined schemas, where data is organized into tables consisting of rows and columns. They utilize SQL as the query language to manipulate and retrieve data, providing powerful capabilities for complex joins, aggregations, and transactions. SQL databases are commonly used in applications that require strong data integrity, ACID compliance, and complex querying, such as financial systems or transactional applications.In contrast, NoSQL databases adopt a more flexible data model, allowing for schema-less data storage. They support various data models like key-value, document, columnar, or graph, catering to diverse data structures and requirements. Each NoSQL database has its own query language specific to its data model. For instance, MongoDB uses a document query language, while Redis employs commands for key-value operations. NoSQL databases prioritize horizontal scalability and are designed to handle large volumes of unstructured or semi-structured data. They excel in use cases with high write/read ratios, real-time analytics, content management systems, and scenarios where the data model may evolve rapidly or have dynamic schema requirements.The choice between SQL and NoSQL databases depends on factors such as data structure, scalability needs, consistency requirements, and the nature of the application. SQL databases are a good fit for applications that demand data integrity and complex querying capabilities, while NoSQL databases are suitable for scenarios where flexibility, scalability, and accommodating dynamic or unstructured data models are crucial. It is important to evaluate the specific needs of a project to make an informed decision between SQL and NoSQL databases."
	},
	{
		"id": 3,
		"ques": "What is express js? What is Nest JS?",
		"ans": "Express.js is a popular and minimalist web application framework for Node.js. It provides a simple and flexible set of features to build web applications and APIs. Express.js allows developers to handle HTTP requests, define routes, handle middleware functions, and render dynamic web pages. It is known for its simplicity and lightweight nature, making it a preferred choice for building small to medium-sized web applications and APIs. Express.js provides a robust ecosystem of plugins and middleware, allowing developers to extend its functionality as needed. NestJS is a progressive Node.js framework built on top of Express.js. It follows the architectural style of Angular and brings a structured and opinionated approach to building server-side applications. NestJS incorporates TypeScript, providing static typing and object-oriented programming concepts to Node.js development. It emphasizes modularity, dependency injection, and a layered architecture to organize and maintain large-scale applications effectively. NestJS supports various features like decorators, dependency injection, middleware, routing, and more. It also integrates well with other libraries and tools commonly used in the Node.js ecosystem.NestJS combines the benefits of Express.js with additional features and architectural patterns, making it a powerful and scalable framework for building enterprise-level applications. It promotes code reusability, testability, and maintainability, making it suitable for complex and large-scale projects. NestJS has gained popularity in the Node.js community for its developer-friendly features and extensive ecosystem."
	},
	{
		"id": 4,
		"ques": "What is a custom hook, and why will you create a custom hook?",
		"ans": "In MongoDB, the `aggregate` method is a powerful feature that allows for advanced data aggregation and processing within the database. It provides a flexible way to perform complex operations on data, including grouping, filtering, sorting, joining, and transforming documents.The `aggregate` method utilizes a pipeline-based approach, where multiple stages are chained together to define the desired data transformation. Each stage represents a specific operation to be performed on the documents in the collection.Here's a high-level overview of how the `aggregate` method works:                                                                                1. Define the pipeline: Construct an array of stages that define the sequence of operations to be executed on the documents. Each stage represents a specific transformation or operation. 2. Specify the stages: The stages can include various operations such as filtering (`$match`), grouping (`$group`), sorting (`$sort`), joining (`$lookup`), projecting (`$project`), and more. Each stage operates on the data and passes the transformed result to the next stage. 3. Execute the aggregation: Call the `aggregate` method on the collection and pass the defined pipeline as an argument. The MongoDB server processes the pipeline stages in the specified order and returns the resulting data.  4. Retrieve the result: The result of the aggregation operation is returned as a cursor, which can be iterated over to access the aggregated data. Depending on the query, the result may contain grouped data, computed fields, or any other transformations applied in the pipeline.The `aggregate` method provides a flexible and powerful way to perform data aggregation within MongoDB. It enables complex data manipulations and calculations directly within the database, reducing the need for multiple round trips between the application and the database server."
	}
]
